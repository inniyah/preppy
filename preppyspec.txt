Title: preppy spec
Version: $Revision: 1.1 $
Author: Aaron Watters <aaron@reportlab.com>
Status: Preliminary, edit out editorial asides before release
Type: Design Specification
Created: 5-Oct-2000


Introduction

    This document describes the preppy.py module operations.
    It is intended for an audience of proficient python programmers
    and is not intended as a user guide for novices.

	Preppy is intended as a simple and fairly general method for
	preprocessing text files containing special markup into python
	programs.  The markup may contain loops and conditional flow
	control and generic python code.  A module generated by preppy
	sends text output to standard output.  Nondirectives in the
	source file are sent unmodified and directives in the source
	file result in computation which may result in substitutions into
	the text output or evaluation of flow control that
	decides whether and how many times segments of text are injected
	into the output stream.

	An example use for Preppy would be to generate a series of similar
	HTML files from the results of database queries -- where the general
	form of the document remains fixed but certain data elements
	change.

	For example consider the Preppy source file

	<html><head><title>${dictionary["name"]$}</title></head><body>
	hello my name is ${dictionary["name"]$} and I am
	${if dictionary["sex"]=="f":$} a gal
	${elif dictionary["sex"]=="m":$} a guy
	${else:$} neuter ${endif$}
	</body></html>

	then with 

	dictionary = {"name": "Fred Flintstone", "sex": "m"}

	the preppy output for this preprocessor source wedded with the
	dictionary input is

        <html><head><title>Fred Flintstone</title></head><body>
        hello my name is Fred Flintstone and I am
         a guy
                </body></html>

	Alternatively with

	dictionary = {"name": "Wilma Flintstone", "sex": "f"}

	We obtain output

	<html><head><title>Wilma Flintstone</title></head><body>
        hello my name is Wilma Flintstone and I am
         a gal
                </body></html>

Intended Use

	Preppy is intended for use in a professional environment with testing.
	In particular there are few provisions to prevent infinite loops or
	NameErrors, or Divide by Zero errors, or other problems familiar to
	professional programmers.  In particular the preppy source

	${script$}from foo import bar; bar()${endscript$}

	may result in an infinite loop or a NameError and we make no provision 
	to attempt to avoid this problem.  Similarly for

	${while 1$}
		INFINITE LOOP!!! ${X$}
	${endwhile$}

	This is only one example of many
	where using the preppy module may result in errors or bugs.

Operations

	Load a preppy module (possibly from source text) using

	m = getPreppyModule(name, directory=".", source_extension=".prep", verbose=0)

	This function will look for the python module named "name" and if
	if exists check to see that it matches the preppy source module
	name+source_extension in the specified directory.  If the
	module does not exist or does not match a new python module
	will be built from the source file, stored as a python module
	name+".py" in the directory (which must be writable if the modules
	don't match.

	If the source module is not present, but the python module is present
	the python module will be assumed correct and used.  When the source
	text and the generated python module match the python code will not
	be regenerated (as an optimization).

	The preppy module itself will keep a cache of those modules previously
	built by preppy and will not reexecute the test/generation code when
	a module of the same name is requested twice -- instead it will provide
	the previously built module.

	The entry point for a Preppy module is the function

		m.run(dictionary)

	Where dictionary provides external information to the run function.
	An example usage might be

	m = getPreppyModule("salutation", directory="/usr/lib/preppy")
	m.run({"name": "Wilma Flintstone", "sex": "f"})



Recursive Imports of preppy modules:

	Recursive imports of preppy modules should use getPreppyModule which
	guarantees that once the module is loaded once it will not be loaded
	a second time. At present there is no special directive to do this.
	Use a script directive.

NonDirectives

	Text not recognized as directives (or partial erroneous directives)
	is sent to standard output unmodified by the run() function.

Directives

	Directives are set off by 

			STARTTAG = "${"
			ENDTAG = "$}"

	these module constants can be altered, but alteration may
	result in parsing difficulties if the replacements are not chosen
	carefully.

	Below are the discussions of the directives in turn.

token:	${token$}

	This construct is recognized if token contains no white space and
	does not match any of the other directives.  The result of this directive
	is the value of token evaluated as a python expression in the context
	of the m.run() function.  An example might be

		${dictionary["name"]$}

	[note: probably should remove the whitespace restriction].

	eval:	${eval$}python_expression${endeval$}

	This {would be} a longer way to spell ${python_expression$} :).

script:	${script$}python_code_line${endscript$}

	or
		${script$}
		many
		lines
		indented
		properly
		${endscript$}

	This executes a sequence of python code within the context of the
	run() function.  An example would be

		${script$}import math; x = math.sin(math.pi/4.0)${endscript$}

	or

		${script$}
		import math
		x = math.sin(math.pi/4.0)${endscript$}

	RESTRICTION: in the multiline case the indentation should follow
	Python conventions (of course) and any initial indentation should be
	character for character the same between the lines of code
	(except for completely white lines).  In particular if the first line
	begins with 8 spaces the next line should not begin with a TAB.

if)	${if condition$} block ${endif$}
	${if condition$} block1 ${else$} block2 ${endif$}
	${if condition$} block1 ${elif condition2$} block2 ${endif$}
	${if condition$} block1 ${elif condition2$} block2 
			${else$} block3 ${endif$}
		...etcetera...

	This conditionally executes segments of text and directives.
	each condition should be a python expression in the context of the
	run() function.  The blocks may contain other directives and text.

for)	${for for_target$} block ${endfor$}

	This implements a for loop in preppy source.  The for_target should follow
	normal python conventions for python for loops.  The resulting python 
	code is roughly

	for for_target:
		interpretation_of(block)
while)	${while condition$} block ${endfor$}

	This implements a while loop in preppy source.  The condition should be
	a python expression.  The resulting python code is roughly

	for for_target:
		interpretation_of(block)
